;;===============================================;; FILE: interface.cl;; These are the funcitions the user calls directly;; ==============================================;; Use this funciton for gcl-chaos.  There is not enough memory in gcl ;; figure the large light structures so only dark structures are looked at. ;; However, for much better results in the crossover function, use the ;; "main-powerlisp" function in a different interpreter with more momeory ;; available.  Powerlisp for the Macintosh has been tested to work.(defun main-chaos (object1 object2 intensity);; Parameters: object1 = the first picture;;             object2 = the second picture;;             intensity = the amount of morphing done    ;; load lists into an array    (let ((objectArray1 (stringLoader (car object1) (cadr object1) (caddr object1)))          (objectArray2 (stringLoader (car object2) (cadr object2) (caddr object2))))        (printarray objectArray1)        (printarray objectArray2)        (format t "Simulation now running, please be patient... ~%~%")        ;; Find major and minor structures in the object        (setf objectStructure1 (findMajorStructures objectArray1 (caddr object1)             (cadr object1)))        (setf objectStructure2 (findMajorStructures objectArray2 (caddr object2)             (cadr object2)))        (format t "Simulation finished, output calculated... ~%~%")        ;; Apply and reapply morphing operators        (do ((i 0 (+ i 1)))          ((>= i intensity) 'done)             ;; Tournament            (setf results (tournament (car (tournamentSelector                                         objectStructure1 objectStructure2))                                       (cadr (tournamentSelector                                         objectStructure1 objectStructure2))))            (swapper objectArray1 objectArray2 (car results) (cadr results))                        ;; Crossover            (setf results (crossover objectStructure1))            (swapper objectArray1 objectArray2 (car results) (cadr results))            ;; Mutation            (mutator objectArray1 objectStructure1))        (printarray objectArray1)        (printarray objectArray2)))(defun main-powerlisp (object1 object2 intensity);; Parameters: object1 = the first picture;;             object2 = the second picture;;             intensity = the amount of morphing done    ;; load lists into an array    (let ((objectArray1 (stringLoader (car object1) (cadr object1) (caddr object1)))          (objectArray2 (stringLoader (car object2) (cadr object2) (caddr object2))))        (printarray objectArray1)        (printarray objectArray2)        (format t "Simulation now running, please be patient... ~%~%")        ;; Find major and minor structures in the object        (setf objectStructure1 (findMajorStructures objectArray1 (caddr object1)             (cadr object1)))        (setf objectStructure2 (findMajorStructures objectArray2 (caddr object2)             (cadr object2)))        (setf minorObjectStruct (findMinorStructures objectArray2 (caddr object1)             (cadr object1)))        (format t "Simulation finished, output calculated... ~%~%")        ;; Apply and reapply morphing operators        (do ((i 0 (+ i 1)))          ((>= i intensity) 'done)             ;; Tournament            (setf results (tournament (car (tournamentSelector                                         objectStructure1 objectStructure2))                                       (cadr (tournamentSelector                                         objectStructure1 objectStructure2))))            (swapper objectArray1 objectArray2 (car results) (cadr results))                        ;; Crossover            (setf results (crossover minorObjectStruct))            (swapper objectArray1 objectArray2 (car results) (cadr results))            ;; Mutation            (mutator objectArray1 minorObjectStruct))        (printarray objectArray1)        (printarray objectArray2)));;===============================================;; FILE: genetic-utility.cl;; This houses most of the genetic utilities;; ==============================================(defun mutator (object  structuredList);; The mutator function randomly takes a character in of a certain ;; type and then replaces it with a character of the opposite type.    (do ((i 0 (+ i 1)))      ((>= i 40) 'done)            (setf aStruct (structSelector (structSelector structuredList)))        ;; if the character is dark, make it light, else make it dark        (if (inList (aref object (car aStruct) (cadr aStruct)))            (setf (aref object (car aStruct) (cadr aStruct)) #\.)            (setf (aref object (car aStruct) (cadr aStruct)) #\@))))(defun crossover (structuredList1);; finds a structure to crossover.  Completely random.    (let ((struct1 (structSelector structuredList1)))    (list (car struct1) (cadr struct1))))(defun tournament (teamA teamB);; tournament fitness based on largest area;; only works correctly with 7 participants, ;; 4 on teamA, 3 on teamB    (let ((set1 '())          (set2 '())          (set3 '()))        (setf set1 (compete (car teamA) (car teamB)))        (if (eq (cdr teamB) 'nil)            (progn                (setf set3 (compete set1 (cadr teamA)))                set3)            (progn                (setf set2 (compete (cadr teamA) (cadr teamB)))                (setf set3 (compete set1 set2))                (compete (tournament (cddr teamA) (cddr teamB)) set3)))))(defun tournamentSelector (structuredList1 structuredList2);; This funciton finds the competitors through a random process    (let ((tourneyA '())          (tourneyB '()))        (do ((i 0 (+ i 1)))          ((>= i 4) 'done)            (setf tourneyA (append tourneyA (list (structSelector structuredList1))))            (setf tourneyB (append tourneyB (list (structSelector structuredList2)))))        ;; Trim the competitors to 7, as determined by Nilsson        (setf tourneyB (cdr tourneyB))        (list tourneyA tourneyB)))(defun structSelector (structureList);; Randomly picks out a structure    (let ((structureLength (random (- (length structureList) 1))))        (do ((i 0 (+ i 1)))          ((>= i structureLength) 'done)            (setf structureList (cdr structureList)))            (car structureList)))(defun compete (teamA teamB);; Fitness is found by comparing two areas.  The larger one wins    (let ((teamA_begin (car teamA))          (teamA_end (cadr teamA))          (teamB_begin (car teamB))          (teamB_end (cadr teamB)))        (let ((teamA_area (* (- (car teamA_end) (car teamA_begin))                            (abs (- (cadr teamA_end) (cadr teamA_begin)))))              (teamB_area (* (- (car teamB_end) (car teamB_begin))                            (abs (- (cadr teamB_end) (cadr teamB_begin))))))            (if (>= teamA_area teamB_area)                teamA                teamB))));;===============================================;; FILE: utils.cl;; This houses most of the generic array utilities;; ==============================================(defun swapper (object1 object2 range1 range2);; Swaps two structures in two arrays    (do ((i (car range1) (+ i 1)))      ((> i (car range2)) 'done)        (do ((j (cadr range1) (+ j 1)))          ((> j (cadr range2)) 'done)                         (swap (aref object1 i j) (aref object2 i j) object1 object2 i j))))(defun swap (charA charB object1 object2 i j)    (setf (aref object1 i j) charB)    (setf (aref object2 i j) charA))(defun adjacent (coordinate1 coordinate2);; Input is important: coordinate1 = this, coordinate2 = last. ;; x coordinates look left for adjacency;; y coordinates look above for adjacency.  diagonals are legal     (let ((nextTo 'nil))    ;; test x        (if (and (eq (+ (car coordinate2) 1) (car coordinate1))                  (eq (cadr coordinate2) (cadr coordinate1)))            (setf nextTo 'T))    ;; test y        (if (and (eq (- (cadr coordinate2) 1) (cadr coordinate1))                (>= (car coordinate2) (- (car coordinate1) 1))                (<= (car coordinate2) (+ (car coordinate1) 1)))            (setf nextTo 'T))        nextTo))(defun completeAdjacencyCheck (structureList nextChar);; This looks for any strucutre that might be adjacent to the current character. ;; If it is, then the character is added to the structure     (let ((change 'nil))        (defun completeCompare (tempList)            (if (equal (car tempList) 'nil) ;; check to see if y+1 = y.next                    change                    (if (adjacent (car tempList) nextChar)                        (setf change 'T)                        (completeCompare (cdr tempList)))))        (if (eq (car structureList) 'nil)            structureList            (progn                ;; compare every node in the current adjacency list for a match                (setf change (completeCompare (cddr (car structureList))))                (if (eq change 'T)                    (progn                        ;; finds out if the addition is unique.  if y.next > y.current                         ;; or x.next > x.current                        (if (or (> (cadr nextChar) (cadr (cadr (car structureList))))                                (> (car nextChar) (car (cadr (car structureList)))))                            (progn                                ;; add to the end of the list                                (setf (cddr (car structureList)) (append (cddr                                     (car structureList)) (list nextChar)))                                ;; change Max Coordinate                                (setf (cadr (car structureList)) nextChar)))                        structureList)                    (append (list (car structureList)) (completeAdjacencyCheck                         (cdr structureList) nextChar)))))))(defun structureLength (structureList);; Find the number of nodes counted in a structure    (let ((lengthStructureLength '()))    (if (eq (cdr structureList) 'nil)        (list (length (car structureList)))        (setf lengthStructureLength (append (structureLength (cdr structureList))             (list (length (car structureList))))))))(defun findMajorStructures (object yMax xMax);; Find all structures that are made up of: % X G B 8 0 $ V 3 @    (let ((structureList '())          (x 0)          (y 0)          (originalListLength '()))        (while (and (< x xMax) (< y yMax))            (setf nextChar (aref object x y))            (if (inList nextChar)                (progn                                      (setf originalListLength (structureLength structureList))                       ;; Since completeAdjacencyCheck adds nodes to the structure if it                     ;; finds them adjacent, the size will be larger than the original.                    ;; If size is same, then add the new, unadjacent character                    (if (equal originalListLength (structureLength                                 (completeAdjacencyCheck structureList (list x y))))                         (setf structureList (append structureList (list (list (list x y)                                 (list x y) (list x y))))))))            ;; resets the character reader at the end of the line            (if (< y  (- yMax 2))                (setf y (+ y 1))                (progn                    (setf x (+ x 1))                    (setf y 0))))                 structureList))(defun inList (char);; finds if a character is a valid dark character        (let ((darkCharacters '(#\% #\X #\G #\B #\8 #\0 #\$ #\V #\3 #\@)))        (defun typeSeeker (charList)            (if (eq (car charList) 'nil)                'nil                (progn                    (if (char= (character char)  (car charList))                        'T                        (typeSeeker (cdr charList))))))        (typeSeeker darkCharacters)))(defmacro while (test &rest body)    `(do ()        ((not ,test))        ,@body))(defun stringLoader (originalPicture xMax yMax);; Loads the picture into an array    (let ((nextChar '0)            ;; i keeps track of the current character position            ;; i is initalized to the character from which we want to start loading          (i 0)          (tempArray (make-array (list xMax yMax) :initial-element 'A))          (x 0))        ;; X. While not EOF and less than max chars per array        (while (and (string/= "}" (string nextChar))                    (<= i (* xMax yMax)))            ;; Y.  While not EOL            (let ((y 0))                (while (string/= "{" (string nextChar))                    (setf nextChar (aref originalPicture i))                    (setf (aref tempArray x y) nextChar)                    (setf i (+ i 1))                    (setf y (+ y 1))))            (setf x (+ x 1))            ;; Get past the EOL char            (setf i (+ i 1))            (setf nextChar (aref originalPicture i)))            tempArray))(defun printArray (object1)    (do ((i 0 (+ i 1)))      ((> i (- (car (array-dimensions object1)) 1)) 'done)        (do ((j 0 (+ j 1)))          ((> j (- (cadr (array-dimensions object1)) 1)) 'done)            (format t "~A" (aref object1 i j)))    (format t "~%")))(defun findMinorStructures (object yMax xMax);; Find all structures that are made up of: / C g : [ ^ .    (let ((minorStructures '())          (x 0)          (y 0)          (originalListLength '()))        (while (and (< x xMax) (< y yMax))            (setf nextChar (aref object x y))            (if (inMedList nextChar)                (progn                                      (setf originalListLength (structureLength minorStructures))                     ;; Since completeAdjacencyCheck adds nodes to the structure if it                     ;; finds them adjacent, the size will be larger than the original.                    ;; If size is same, then add the new, unadjacent character                    (if (equal originalListLength (structureLength                             (completeAdjacencyCheck minorStructures (list x y))))                         (setf minorStructures (append minorStructures (list (list                                 (list x y) (list x y) (list x y))))))))            ;; resets the character reader at the end of the line            (if (< y  (- yMax 2))                (setf y (+ y 1))                (progn                    (setf x (+ x 1))                    (setf y 0))))         minorStructures))(defun inMedList (char);; finds if a character is a valid medium-light characte    (let ((medCharacters '(#\/ #\C #\g #\: #\[ #\^ #\.)))        (defun typeSeeker (charList)            (if (eq (car charList) 'nil)                'nil                (progn                    (if (char= (character char)  (car charList))                        'T                        (typeSeeker (cdr charList))))))    (typeSeeker medCharacters)));;===============================================;; FILE: data.cl;; This houses  the data ;; ==============================================;; DATA STRUCTURES:;;  structureList: a list of formations given a degree of intensity ;;                  (light, medium and dark structures);;  all objects: Object, width, height(setf face1 '("?????????????????????????????????????????????????????????????????{?                       /X3G800B$$$$$B0g                        ?{?                 /VGg$$$$@@$$$$$$@@@@@@@@@$B0%V                ?{?               VG$@@$BB@$0g88g0BBB$$@@@@@@@@@@$3V              ?{?             CG@@$$0g8%%%%%%333G%%%GG88gB@@@@@@$$8X            ?{?           30@BB008CVVXV/XX//VVXVVVVCCVXV3G0$@@@@@@0V          ?{?         /g@$Bgg%VX///[[:[////[[/////[[/XXVCG0$@@@@@@03        ?{?        %$B08GV/[[:~^:[[::/[///[[[[[::::[///X3G$@@@@@@@G       ?{?       8g8G3V[`        ``^::[[:~::::::~::::::/X3g@@@@@@@8      ?{?     /3g%33V:               ``` `````````.^^^~:/C80$@@@@B      ?{?     /3CX/X:                        ``````^^^^~:[V%80$$$$      ?{?     [/[//:                         `` ````.^^:::/3gBB00$      ?{?     [[3X:`                              ```.^:::/30$@@@$      ?{?     XG8/^                               ````^^::[VGB@@@@      ?{?     V08/^                             ``````^^::[XC8$@@@      ?{?     X03[^                               ````^^::[/VG$@@@      ?{?     X03[.                               ````^^:::[X%$@@@      ?{?     X03:`                               ```.^^::::[30@$$      ?{?     /g%^     `                        ^~://X//:^^:~[0$0@      ?{?    [[g%   ^:XCCCVX[:^`           ^:/C%GGG%333%G3[:::0B0@/:::  ?{?    `:%G  .:/X//V3%8008V/:` ````^:V%G88CX[::^~::XV:::G$0V^^[X  ?{?  V/  :0  ^::::[///V33VCV[^`..`^:[VVXXX^``~/X/:[^/:::8$3^:^::: ?{? ^//^`^%  `:[/VV///VCCVCVX[^`` ^:[/XX//33G////:[:::~:%$[^``:^: ?{?  /`  `/   `:/VX[:8G8:~/[/X:   ^::::^.`%GC^^VC[::~~::/$[[:^^^: ?{? :` ::X[    `.`^^^~^^..`:/[`  `^::^.^^^:^~:::^^^^^^[::B.`:^:`: ?{? : :[:/[        ^::::^~:^^     `::^^^^.```^`^`^.`~^:[:8^`^^^^  ?{? [ ^[/[[                     ``.::^``` ````..```.^:::/[`^:~^:  ?{? [^ `^/[``                     ^::^```````````` ^~::[[^:::~^:  ?{? [:`  ^:```                   `.~::^`````````.`.:::://~^^^^:   ?{?  [:` ~:^``.`          `      `^~::~````````^^^~:::[/[``.^:[   ?{?       :: ^^.```   ````~    `  ^^:[:^.``````^^~:::[:/V:::[/    ?{?        [`^^^^^``````.:/^~. ```.:[::::^``.^^^:::::::/V         ?{?        [^``.^^`^``^^^:/::[[:[:[/X[~^^^.``^^::^~::://          ?{?        [: .^^`.^``...^^^`^/VV/:::::^^^^`.^^~:^~:::/           ?{?        [[ .^^`.^`````.^~::[[::^:[::::^^.^^^^:^:^:::           ?{?         [^`^`.```.^::::^`    ` ``.^^::~:~^^^~::~~:/           ?{?          ~.`.^^``^::[/V%%CXXX//VC%3CX/::^^~::::::/            ?{?          ::.^^^`^:::^:~::~:[[:::^^^^.`~^^^::::::[/            ?{?           [^^^^^:::^`````.^^^^.^^^^^^^^^^::::::/:/            ?{?           /`^:^:::^^^^^:::::::::::~^^^:^~::::[/::/            ?{?           [`^::~:::~^^^:::[[[[[::^^^^^^::[:::/~::/            ?{?           /``.::[:~:~^^^..^^.`````^^^^^:::[/[:~^:/            ?{?           /````~:[::^`````````^.``.^~:::[//[~.^^:/            ?{?           /``^^^^:[[:::^^^^^^^^^.^^~:://X/:^^^^~:/            ?{?           [`.^^^^~:[///[::::::::~::[/XV/:~^^^^~~:/            ?{?           :`^^^^:~::::XXX/////[[//VVXX[:^~^^^~^~:/            ?{?          /^`^^^^~~::::::/XVC333CCVX/:::~~~^^^~~~:/            ?{?          /` ^^^~:::::::[[::[//X//[::::::~^^^^^:~:/            ?{?????????????????????????????????????????????????????????????????{}" 49 66))(setf face2 '("?????????????????????????????????????????????????????????????????{?                         3g00gg8G%V                            ?{?                     V8B$$$BB$@B$$$$$B08C                      ?{?                   GB@@@$$@@@Bg@@$00000$@$%                    ?{?                 %B@@$$B$$BBB$@$$$$$$$B$BBBBg%C                ?{?              %B$@$B$$$B@$B$$B$$$BBBB00BBBBBBB$$C:             ?{?            8@$$$B$$$$B$$$B$0gB$BBBBBB0BBBBBBB$B$@@8C          ?{?          G$$B$$$B$B0B$$$0BB8G0BB000000000BBBBB$$$B$@g         ?{?        XB@BB$$$BB$$$BBBB00g%3G0gG333%G888g0BB000B$$@$g        ?{?       Xg@$B$$B$$BB000g8%3CX[[[//[:^~:[XXVC%g00B00BBBB$$V      ?{?      /$$$BBBB0$BB08%3CV/:::::^^^^^```.^^^:[X3%800g0B$B$$X     ?{?     X$$BB$B0ggg88%C/[:::::^^^^^.``````````^^:[:/VC%0BB$$$     ?{?     g@B$$B0g%CVVVX/[:::::^^^^.`            `^^^^^:/V38$$$0    ?{?    g@BB$$0G3VX///[[::::^.````             ``.`^^^^^[V%8$$$X   ?{?    $@$$$08%C/[/[[[::~^^``               ``````^^^^^^[V%8B@G   ?{?    @$$$$Bg3X///[[:::^^^``````        `````    `^~^.^:[3%8$BX  ?{?    @$$BB0GC////[:::~^^.``````                  `^^.^^:X3gB$C  ?{?    @0$$0G3VX//[::~^^.``` ``                     ``.^^^:XgBBC  ?{?   g@g@@%XC3X//X/XX[:^``                    :[///X/[[::^:%$$3  ?{?   8@B$0%VXXV38%33G8GG8%3X:`           `           `~[/^:%$@3  ?{?   XB$$0%XV%%X:^``.~:/X//X/:^`       `^:::::^.`      `^^~CB@%  ?{?  Xg@B$B3X3%/::`````^::[::[[[^``` ```.::::/[:^^:~^^`  .^^XgBV  ?{? ///G@BB3VV/[::^[/[^`^`^:[[[[//^`  `^^^.::.:V/XX:[/^`^``^:0%   ?{?^:[//G@03VX/[/[VCV/BVV[ `^^:::[:`  ``  ``` ^%3V `[X~ ```~:3C   ?{?:[X/[3$8CX/:[//CG/ X%8:  `:~^:/:`  ``  ^`^  :^`    ``  ``^/    ?{?:X/:[%%3VX[::::::``  ` `  .::[[^.   `^^. ^^```         ` ^     ?{?^V::V[/CX/::^.`   ````   `^:[[:~`    `^^`                ~     ?{?`:/C3:^3V/[:^`           `^:[[::.    ``^`              ``^     ?{? [:/3V/VV/[:^`           ^:[[:::^`   ``^`              ``^     ?{?  [/::/VVX[::.          `^//[:::.`    ``^^`            .^:     ?{?   [//[XVX/[:~`        `^[/:^^^^         ``           `^::     ?{?    [/[[/VX/[:^``    ``^:[[::::`      ^:~^     ^`` `^^::[[     ?{?          XVX/[:^..^.^^^^::[[[[V/^.^:^``    ````^:^^~::::      ?{?          /3CX/[::::^^::::::::[::^``^^^~^^~~~^^.^::::::[       ?{?          /CVVV/[[[:~:/[[/XX/[[:^  ``^^ `^:::[/:^`^:::::       ?{?          /%XVC//[[::[CC//[^.`  `..`.^..:^^[V[^^``^::::        ?{?          /%VVXVX/[:~:[XVV[^^^ .          `:^ ```^::::         ?{?          /%CVXX///[:~^~:[:`          ``^^^^` `^~:::::         ?{?          [3CCVX/////[::~:/[:^`         ````  `^::::[[         ?{?          XC/CVCV/////[:::[/[::`     ``^^`  ```^:~:::[         ?{?          /CXCXVVXXX//[::::::::[::[[:::``   ``^^:::::[         ?{?         /VVVVXXVVVX////[::^^^^^`.^^`        `.^:::::[         ?{?         x%VV/VXXXVVVX///[:^``              ``^::::::[         ?{?         xCXX/XXXXXVVVV/[[[:^```           `.^:::::::Y.        ?{?        /GVX///////XXVVCX/[::^^  ````` ```^~::::::::::YY       ?{?       XG%X//////////XXVVVV/[::^^.`.^^^~^~:[[:::::::::XXY      ?{?      YX%%X////[[[[[////XVXX///[[[[[[[[:::::::~:::::::XXG\      ?{?     [3/33X//[[[[:::[[////////[[[[[[[::~:::::^^^^^^:::XXXG\     ?{?????????????????????????????????????????????????????????????????{}" 49 66))(setf shell '("?????????????????????????????????????????????????????????????????{?                                                               ?{?                      $B0gggg8838gg000$                        ?{?                  0G%%%CVCC3%%%33%%8g0g8800$                   ?{?               0%VVC3VVXXV333CVVVVC3%%GG888V%g                 ?{?             8VV/CC3VVXXVCCCVV//XVC3333CC3%GggG8$              ?{?           8XX/[C3CVV/[VCVX/<^</VVVXXXVVVCCC3%80GG$            ?{?         $VXVX[[%VVX/.`X//:~^<~XX//[[[[XVCCXV3%800GG$          ?{?        0/XCV/[XVV//[</[<<[/CXX[[[[[:<`^VVCC3CC33%8838         ?{?       g[<CVX/[<`[<<<[X[^` V/[[^<<</[//////XXXXXVVC33VV$       ?{?      G<<[CV/[/` <^~~[<<   ^^      </X/[:<<:<<<[/XVC3%%VB      ?{?     B</<<X//<<^ ^<  ///. [V^`     ~~^<[[[[[[[ [XXVVV3%GXg     ?{?    $X[//<<`^<.^~[<< X%X~[[V<<   `^        ^::[/////XVC%G/B    ?{?    $^:X/<[   <` /%3[<`^  ^^~//~`[        /3%%%%%%%CCXX3G8/$   ?{?    g^[C/<^^  ^<^<V^`       ``^<X<~   `<XG88GCX//V3%%G%CV8GC$  ?{?    3~^[<^^`^^^V3V  `          `^[X`^[</////V33V/[/XV3%%G%G/B  ?{?   $X<^``  `^^ .G``    ^<<^   ` ^^[X^[`       `[VC3VVVV33%%C/$ ?{?   $3<[~^^ `^[XGG^`  `<^<[[X`` ```^/X  `^^^^^   `[C3%GG%%%G8`$ ?{?    %~/[^^ ^^ `03^   [    <X[``. `^<V ^^<<~~<<<<  ~/VCC%GG883% ?{?    $^^^   `^^[Gg[^  <[^^ `^[`^.`^.</^^^^~^^~<<<:    <[///C%gC ?{?    $/^`   `^^^%08<        :`^^<  ^^X<~~<^^^^~^<[/   [//XXVC83 ?{?    $0^<<^` `^^<VgB%<`    ~^^^~`^`^^<^^~<<<<<<<<<:/` ^//XCCC%V ?{?     $3`^^   `^  [g%00V8%[/``^^  ` /^^^~<<<<<:<[[///~`</VC3C3/ ?{?      $3`        ^  /8 /% ^< ^  `^ ^^^^~<<<<<[<[[/////<[/VCV3X ?{?        %``^^`      ^` ^[ `     `<^^^^^^~<<<<<<<:[/XXVX[[[XV3V ?{?         0<``                 ` .<^^^^^^~^<<<<<<:.^<X//:[/VV3V ?{?           g/`               ^^VC^^^^^^^^^<<<<:[[/[//[[[//XX33 ?{?             $GV[^`     ``^[C80C<^^^^~~^^^^~<<<[[/////[/X//V/$ ?{?                   B0g8g     G/^^^^^^<~<~<~^~<<[[[////[/VXXCV$ ?{?                          08V<^.^^^`^^^<<~<<<<<[<[////[///X/$  ?{?                      $B0%X<^```..``.^~~<<<<<:<[[[[//XX//XV3   ?{?          0Gg000000g8%3V[<^`````.^```.^~^<<<<[<[/////////X/$   ?{?        0<<[:////X/[<<~^`````````^.`.`.^~~<[:<[:[[[/XV////g    ?{?      $V`~`   `^^`  ````` `  ````^^`.``.^<<<[[[[<<[[//[//%     ?{?     $< ^    `^^   ```` ` `  `` ``^.^``^^^<<[[[[[///////3      ?{?    $/ `    ``^    ``` `     `` ``^^^^`^^<<<<[//XX//[/[%$      ?{?   $/   `   `.`    ` `        `` `.^^~^~<<<<<[[///[[[[%        ?{?   $^  `   ```    `` `         ````^~<<<<<[[[[[/[<:[[g         ?{?  $0  `    ```   ` `          `````^~<[<<:[///[<<<[C$          ?{?   G`^` ``````   ` ` ` ```  ````^^^^<<[[[[[[[<<<<XB            ?{?   8[[<<<~^^^` `` ``````````^^^^^^~<<<<[[[[<<<<[8              ?{?   %[[::[[:<<~^^``^^^^^^^^^^^^^^~<<<<<<<<<<<<[%                ?{?   CX/[[[[:[:<~<^`~^~^^~^^~~~<<<<<<<<<^^~<^/8                  ?{?  $VX///[[[/[<<<<^<<<<<<<<<<<<<<<<^^^^^^<V0                    ?{?  3[[//[////[<<<<~<<<<<<<<<<<^^^^.^^^~Xg                       ?{? g[<<<<<<<<<<<<<<^^~~~^^^^^^....^</30                          ?{?   83V/<^^~<~~^^^^^^^^^^^`.<[V%g                               ?{?         Bg8G%33CCVVC%GG8B                                     ?{?????????????????????????????????????????????????????????????????{}" 49 66))
<HTML><HEAD><TITLE>Genetic ASCII Art Week 1</TITLE></HEAD><BODY bgcolor = white><H2><CENTER>810:161 Project Week 1<BR>David Schmudde</CENTER></H2>Having delt with the data for the first time, I can now derive ways of combining and manipulating it.  For example, combining random parts of three photos of faces (<A HREF = "male1.htm">Person 1</A>, <A HREF = "male2.htm">Person 2</A>, <A HREF = "female2.htm">Person 3</A>) yields a rather sloppy result.  In order to even achieve this <A HREF = "mergertest1.htm">result</A>, the pictures will be gridded off with genderal areas swapped (general area of a nose, for a general area of a nose).  To increase accuracy, the data to be swapped is finely adjusted by how much white space surrounds the features.<BR><BR>Solution: The program must look at jagged edges and dither them.  Then, the program might produce this <A HREF = "mergertest2.htm">result2</A>.  A much more interesting and dynamic result.  I am rather pleased that the more that the user runs the program the more distorted the image becomes.  Remember, this is not a morphing program, combining structures so that the user can definatly discern the represented elements, this is an abstraction program.<BR><BR><BR>An object that divides a picture up into rows would look like this:<PRE>(defclass aObject ()    ((wholePicture  :accessor wholePicture                    :initarg  :currentState                    :initform (setf states (make-array '(49 66)                                :initial-element 'A)))     (row1          :accessor row1<BR>                    :initarg  :defineRow1                    :initform (setf states (make-array '(7 66)                                :initial-element 'A)))     (row2          :accessor row2                    :initarg  :defineRow2                    :initform (setf states (make-array '(7 66)                                :initial-element 'A)))     (row3          :accessor row3                    :initarg  :defineRow3                    :initform (setf states (make-array '(7 66)                                :initial-element 'A)))     (row4          :accessor row4                    :initarg  :defineRow4                    :initform (setf states (make-array '(7 66)                                :initial-element 'A)))     (row5          :accessor row5                    :initarg  :defineRow5                    :initform (setf states (make-array '(7 66)                                :initial-element 'A)))     (row6          :accessor row6                    :initarg  :defineRow6                    :initform (setf states (make-array '(7 66)                                :initial-element 'A)))     (row7          :accessor row7                    :initarg  :defineRow7                    :initform (setf states (make-array '(7 66)                                :initial-element 'A)))    (objectType     :accessor objectType                    :initarg  :defineObjectType                    :initform 'object)    (sweetSpots     :accessor sweetSpot                    :initarg  :defineSweetSpots                    :initform '())))(setf aPicture (make-instance 'aObject :defineObjectType 'face));; set one element(setf (aref (row1 aPicture) 0 0) 'b)</PRE>Here, sweet spots are coordinates pertaining to the original photo that are considered important details (the leaf of a plant or the nose of a person, for example) of the object.  <BR><BR>As I work on the project I will create a larger data set of original pictures for the program to work from.  I do not plan for the user to ever see these.<BR> </BODY></HTML>
(defun swapper (object1 object2 range1 range2);; Swaps two structures in two arrays	(do ((i (car range1) (+ i 1)))	  ((> i (car range2)) 'done)		(do ((j (cadr range1) (+ j 1)))		  ((> j (cadr range2)) 'done)			 			(swap (aref object1 i j) (aref object2 i j) object1 object2 i j))))(defun swap (charA charB object1 object2 i j)	(setf (aref object1 i j) charB)	(setf (aref object2 i j) charA))(defun adjacent (coordinate1 coordinate2);; Input is important: coordinate1 = this, coordinate2 = last. ;; x coordinates look left for adjacency;; y coordinates look above for adjacency.  diagonals are legal 	(let ((nextTo 'nil))	;; test x		(if (and (eq (+ (car coordinate2) 1) (car coordinate1)) 				 (eq (cadr coordinate2) (cadr coordinate1)))			(setf nextTo 'T))	;; test y		(if (and (eq (- (cadr coordinate2) 1) (cadr coordinate1))				(>= (car coordinate2) (- (car coordinate1) 1))				(<= (car coordinate2) (+ (car coordinate1) 1)))			(setf nextTo 'T))		nextTo))(defun completeAdjacencyCheck (structureList nextChar);; This looks for any strucutre that might be adjacent to the current character. ;; If it is, then the character is added to the structure 	(let ((change 'nil))		(defun completeCompare (tempList)			(if (equal (car tempList) 'nil) ;; check to see if y+1 = y.next					change					(if (adjacent (car tempList) nextChar)						(setf change 'T)						(completeCompare (cdr tempList)))))		(if (eq (car structureList) 'nil)			structureList			(progn				;; compare every node in the current adjacency list for a match				(setf change (completeCompare (cddr (car structureList))))				(if (eq change 'T)					(progn						;; finds out if the addition is unique.  if y.next > y.current 						;; or x.next > x.current						(if (or (> (cadr nextChar) (cadr (cadr (car structureList))))								(> (car nextChar) (car (cadr (car structureList)))))							(progn								;; add to the end of the list								(setf (cddr (car structureList)) (append (cddr 									(car structureList)) (list nextChar)))								;; change Max Coordinate								(setf (cadr (car structureList)) nextChar)))						structureList)					(append (list (car structureList)) (completeAdjacencyCheck 						(cdr structureList) nextChar)))))))(defun structureLength (structureList);; Find the number of nodes counted in a structure	(let ((lengthStructureLength '()))	(if (eq (cdr structureList) 'nil)		(list (length (car structureList)))		(setf lengthStructureLength (append (structureLength (cdr structureList)) 			(list (length (car structureList))))))))(defun findMajorStructures (object yMax xMax);; Find all structures that are made up of: % X G B 8 0 $ V 3 @	(let ((structureList '())		  (x 0)		  (y 0)		  (originalListLength '()))		(while (and (< x xMax) (< y yMax))			(setf nextChar (aref object x y))			(if (inList nextChar)				(progn										(setf originalListLength (structureLength structureList))						;; Since completeAdjacencyCheck adds nodes to the structure if it 					;; finds them adjacent, the size will be larger than the original.					;; If size is same, then add the new, unadjacent character					(if (equal originalListLength (structureLength 								(completeAdjacencyCheck structureList (list x y)))) 						(setf structureList (append structureList (list (list (list x y) 								(list x y) (list x y))))))))			;; resets the character reader at the end of the line			(if (< y  (- yMax 2))				(setf y (+ y 1))				(progn					(setf x (+ x 1))					(setf y 0)))) 				structureList))(defun inList (char);; finds if a character is a valid dark character        (let ((darkCharacters '(#\% #\X #\G #\B #\8 #\0 #\$ #\V #\3 #\@)))		(defun typeSeeker (charList)			(if (eq (car charList) 'nil)				'nil				(progn					(if (char= (character char)  (car charList))						'T						(typeSeeker (cdr charList))))))        (typeSeeker darkCharacters)))(defmacro while (test &rest body)	`(do ()		((not ,test))		,@body))(defun stringLoader (originalPicture xMax yMax);; Loads the picture into an array	(let ((nextChar '0)			;; i keeps track of the current character position			;; i is initalized to the character from which we want to start loading		  (i 0)		  (tempArray (make-array (list xMax yMax) :initial-element 'A))		  (x 0))		;; X. While not EOF and less than max chars per array		(while (and (string/= "}" (string nextChar))					(<= i (* xMax yMax)))			;; Y.  While not EOL			(let ((y 0))				(while (string/= "{" (string nextChar))					(setf nextChar (aref originalPicture i))					(setf (aref tempArray x y) nextChar)					(setf i (+ i 1))					(setf y (+ y 1))))			(setf x (+ x 1))			;; Get past the EOL char			(setf i (+ i 1))			(setf nextChar (aref originalPicture i)))			tempArray))(defun printArray (object1)	(do ((i 0 (+ i 1)))	  ((> i (- (car (array-dimensions object1)) 1)) 'done)		(do ((j 0 (+ j 1)))		  ((> j (- (cadr (array-dimensions object1)) 1)) 'done)			(format t "~A" (aref object1 i j)))	(format t "~%")))(defun findMinorStructures (object yMax xMax);; Find all structures that are made up of: / C g : [ ^ .	(let ((minorStructures '())		  (x 0)		  (y 0)		  (originalListLength '()))		(while (and (< x xMax) (< y yMax))			(setf nextChar (aref object x y))			(if (inMedList nextChar)				(progn										(setf originalListLength (structureLength minorStructures))						;; Since completeAdjacencyCheck adds nodes to the structure if it 					;; finds them adjacent, the size will be larger than the original.					;; If size is same, then add the new, unadjacent character					(if (equal originalListLength (structureLength 							(completeAdjacencyCheck minorStructures (list x y)))) 						(setf minorStructures (append minorStructures (list (list 								(list x y) (list x y) (list x y))))))))			;; resets the character reader at the end of the line			(if (< y  (- yMax 2))				(setf y (+ y 1))				(progn					(setf x (+ x 1))					(setf y 0)))) 		minorStructures))(defun inMedList (char);; finds if a character is a valid medium-light characte	(let ((medCharacters '(#\/ #\C #\g #\: #\[ #\^ #\.)))		(defun typeSeeker (charList)			(if (eq (car charList) 'nil)				'nil				(progn					(if (char= (character char)  (car charList))						'T						(typeSeeker (cdr charList))))))	(typeSeeker medCharacters)))